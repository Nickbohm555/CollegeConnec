{"ast":null,"code":"const fetch = require('node-fetch');\n\nconst xml2js = require('xml2js');\n\nconst util = require('./util');\n\nconst urls = require('./url');\n\nconst constant = require('./constant');\n\nconst defaultOptions = {\n  protocol: 'https',\n  path: '/cas',\n  version: constant.CAS_VERSION_3_0,\n  proxy_callback_url: '',\n  validation_proxy: false,\n  validation_proxy_protocol: '',\n  validation_proxy_endpoint: '',\n  validation_proxy_path: ''\n};\n\nclass CasClient {\n  constructor(endpoint) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (util.isEmpty(endpoint)) {\n      util.throwError('Missing endpoint');\n    }\n\n    let version = options.version || defaultOptions.version;\n\n    if (!constant.CAS_VERSIONS.includes(version)) {\n      util.throwError('Unsupported CAS Version');\n    }\n\n    this.endpoint = endpoint;\n    this.path = options.path || defaultOptions.path;\n    this.protocol = options.protocol || defaultOptions.protocol;\n    this.version = options.version || defaultOptions.version;\n    this.proxy_callback_url = options.proxy_callback_url || defaultOptions.proxy_callback_url;\n    this.validation_proxy = options.validation_proxy || defaultOptions.validation_proxy;\n    this.validation_proxy_protocol = options.validation_proxy_protocol || defaultOptions.validation_proxy_protocol;\n    this.validation_proxy_endpoint = options.validation_proxy_endpoint || defaultOptions.validation_proxy_endpoint;\n    this.validation_proxy_path = options.validation_proxy_path || defaultOptions.validation_proxy_path;\n    this.redirectUrl = util.getCurrentUrl();\n  }\n\n  auth() {\n    let gateway = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return new Promise((resolve, reject) => {\n      /**\n       * Save ticket to sessionStorage if exists\n       */\n      const ticket = util.getParamFromCurrentUrl('ticket');\n\n      if (util.isEmpty(ticket)) {\n        let status = util.getParamFromCurrentUrl('status');\n\n        if (status === constant.CAS_STATUS_IN_PROCESS) {\n          this._handleFailsValdiate(reject, {\n            type: constant.CAS_ERROR_AUTH_ERROR,\n            message: 'Missing ticket from return url'\n          });\n        } else {\n          window.location.href = urls.getLoginUrl(this, gateway);\n        }\n      } else {\n        this._validateTicket(ticket, resolve, reject);\n      }\n    });\n  }\n\n  logout() {\n    let redirectPath = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    window.location.href = urls.getLogoutUrl(this, redirectPath);\n  }\n\n  _getSuccessResponse(user) {\n    let pgtIou = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let response = {\n      currentUrl: window.location.origin + window.location.pathname,\n      currentPath: window.location.pathname,\n      user: user\n    };\n\n    if (pgtIou) {\n      response.pgtIou = pgtIou;\n    }\n\n    return response;\n  }\n\n  _validateTicket(ticket, resolve, reject) {\n    let version = this.version;\n    let content_type;\n\n    switch (version) {\n      case constant.CAS_VERSION_2_0:\n        content_type = 'text/xml';\n        break;\n\n      case constant.CAS_VERSION_3_0:\n        content_type = 'application/json';\n        break;\n\n      default:\n        throw util.throwError('Unsupported CAS Version');\n    }\n\n    fetch(urls.getValidateUrl(this, ticket), {\n      headers: {\n        'Content-Type': content_type\n      }\n    }).then(function (response) {\n      response.text().then(function (text) {\n        switch (version) {\n          case constant.CAS_VERSION_2_0:\n            xml2js.parseStringPromise(text).then(function (result) {\n              let response = result['cas:serviceResponse'];\n\n              if (response['cas:authenticationSuccess']) {\n                let successes = response['cas:authenticationSuccess'];\n\n                if (successes.length) {\n                  let user = successes[0]['cas:user'][0];\n                  let pgtIou = null;\n\n                  if (!util.isEmpty(this.proxy_callback_url)) {\n                    pgtIou = successes[0]['cas:proxyGrantingTicket'][0];\n                  }\n\n                  this._handleSuccessValdiate(resolve, user, pgtIou);\n\n                  this._handleSuccessValdiate(resolve, user);\n                }\n              } else {\n                let failures = response['cas:authenticationFailure'];\n\n                if (failures.length) {\n                  this._handleFailsValdiate(reject, {\n                    type: constant.CAS_ERROR_AUTH_ERROR,\n                    code: failures[0].$.code.trim(),\n                    message: failures[0]._.trim()\n                  });\n                }\n              }\n            }.bind(this)).catch(function (error) {\n              this._handleFailsValdiate(reject, {\n                type: constant.CAS_ERROR_PARSE_RESPONSE,\n                message: 'Failed to parse response',\n                exception: error\n              });\n            }.bind(this));\n            break;\n\n          case constant.CAS_VERSION_3_0:\n            try {\n              let json = JSON.parse(text);\n\n              if (json.serviceResponse) {\n                if (json.serviceResponse.authenticationSuccess) {\n                  let user = json.serviceResponse.authenticationSuccess.user;\n                  let pgtIou = null;\n\n                  if (!util.isEmpty(this.proxy_callback_url)) {\n                    pgtIou = json.serviceResponse.authenticationSuccess.proxyGrantingTicket;\n                  }\n\n                  this._handleSuccessValdiate(resolve, user, pgtIou);\n                } else {\n                  this._handleFailsValdiate(reject, {\n                    type: constant.CAS_ERROR_AUTH_ERROR,\n                    code: json.serviceResponse.authenticationFailure.code,\n                    message: json.serviceResponse.authenticationFailure.description\n                  });\n                }\n              }\n            } catch (error) {\n              this._handleFailsValdiate(reject, {\n                type: constant.CAS_ERROR_PARSE_RESPONSE,\n                message: 'Failed to parse response',\n                exception: error\n              });\n            }\n\n            break;\n\n          default:\n            throw util.throwError('Unsupported CAS Version');\n        }\n\n        throw util.throwError('Stop...');\n      }.bind(this)).catch(function (error) {\n        this._handleFailsValdiate(reject, {\n          type: constant.CAS_ERROR_PARSE_RESPONSE,\n          message: 'Failed to parse response',\n          exception: error\n        });\n      }.bind(this));\n    }.bind(this)).catch(function (error) {\n      this._handleFailsValdiate(reject, {\n        type: constant.CAS_ERROR_FETCH,\n        message: 'Failed to connect CAS server',\n        exception: error\n      });\n    }.bind(this));\n  }\n\n  _handleSuccessValdiate(callback, user) {\n    let pgtIou = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    callback(this._getSuccessResponse(user, pgtIou));\n  }\n\n  _handleFailsValdiate(callback, error) {\n    error.currentUrl = window.location.origin + window.location.pathname;\n    error.currentPath = window.location.pathname;\n    callback(error);\n  }\n\n}\n\nexport default CasClient;\nexport { constant };","map":{"version":3,"sources":["C:/Users/joshu/Capstone/Capstone-2/node_modules/react-cas-client/lib/index.js"],"names":["fetch","require","xml2js","util","urls","constant","defaultOptions","protocol","path","version","CAS_VERSION_3_0","proxy_callback_url","validation_proxy","validation_proxy_protocol","validation_proxy_endpoint","validation_proxy_path","CasClient","constructor","endpoint","options","isEmpty","throwError","CAS_VERSIONS","includes","redirectUrl","getCurrentUrl","auth","gateway","Promise","resolve","reject","ticket","getParamFromCurrentUrl","status","CAS_STATUS_IN_PROCESS","_handleFailsValdiate","type","CAS_ERROR_AUTH_ERROR","message","window","location","href","getLoginUrl","_validateTicket","logout","redirectPath","getLogoutUrl","_getSuccessResponse","user","pgtIou","response","currentUrl","origin","pathname","currentPath","content_type","CAS_VERSION_2_0","getValidateUrl","headers","then","text","parseStringPromise","result","successes","length","_handleSuccessValdiate","failures","code","$","trim","_","bind","catch","error","CAS_ERROR_PARSE_RESPONSE","exception","json","JSON","parse","serviceResponse","authenticationSuccess","proxyGrantingTicket","authenticationFailure","description","CAS_ERROR_FETCH","callback"],"mappings":"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","sourcesContent":["const fetch = require('node-fetch');\n\nconst xml2js = require('xml2js');\n\nconst util = require('./util');\n\nconst urls = require('./url');\n\nconst constant = require('./constant');\n\nconst defaultOptions = {\n  protocol: 'https',\n  path: '/cas',\n  version: constant.CAS_VERSION_3_0,\n  proxy_callback_url: '',\n  validation_proxy: false,\n  validation_proxy_protocol: '',\n  validation_proxy_endpoint: '',\n  validation_proxy_path: ''\n};\n\nclass CasClient {\n  constructor(endpoint, options = {}) {\n    if (util.isEmpty(endpoint)) {\n      util.throwError('Missing endpoint');\n    }\n\n    let version = options.version || defaultOptions.version;\n\n    if (!constant.CAS_VERSIONS.includes(version)) {\n      util.throwError('Unsupported CAS Version');\n    }\n\n    this.endpoint = endpoint;\n    this.path = options.path || defaultOptions.path;\n    this.protocol = options.protocol || defaultOptions.protocol;\n    this.version = options.version || defaultOptions.version;\n    this.proxy_callback_url = options.proxy_callback_url || defaultOptions.proxy_callback_url;\n    this.validation_proxy = options.validation_proxy || defaultOptions.validation_proxy;\n    this.validation_proxy_protocol = options.validation_proxy_protocol || defaultOptions.validation_proxy_protocol;\n    this.validation_proxy_endpoint = options.validation_proxy_endpoint || defaultOptions.validation_proxy_endpoint;\n    this.validation_proxy_path = options.validation_proxy_path || defaultOptions.validation_proxy_path;\n    this.redirectUrl = util.getCurrentUrl();\n  }\n\n  auth(gateway = false) {\n    return new Promise((resolve, reject) => {\n      /**\n       * Save ticket to sessionStorage if exists\n       */\n      const ticket = util.getParamFromCurrentUrl('ticket');\n\n      if (util.isEmpty(ticket)) {\n        let status = util.getParamFromCurrentUrl('status');\n\n        if (status === constant.CAS_STATUS_IN_PROCESS) {\n          this._handleFailsValdiate(reject, {\n            type: constant.CAS_ERROR_AUTH_ERROR,\n            message: 'Missing ticket from return url'\n          });\n        } else {\n          window.location.href = urls.getLoginUrl(this, gateway);\n        }\n      } else {\n        this._validateTicket(ticket, resolve, reject);\n      }\n    });\n  }\n\n  logout(redirectPath = '') {\n    window.location.href = urls.getLogoutUrl(this, redirectPath);\n  }\n\n  _getSuccessResponse(user, pgtIou = null) {\n    let response = {\n      currentUrl: window.location.origin + window.location.pathname,\n      currentPath: window.location.pathname,\n      user: user\n    };\n\n    if (pgtIou) {\n      response.pgtIou = pgtIou;\n    }\n\n    return response;\n  }\n\n  _validateTicket(ticket, resolve, reject) {\n    let version = this.version;\n    let content_type;\n\n    switch (version) {\n      case constant.CAS_VERSION_2_0:\n        content_type = 'text/xml';\n        break;\n\n      case constant.CAS_VERSION_3_0:\n        content_type = 'application/json';\n        break;\n\n      default:\n        throw util.throwError('Unsupported CAS Version');\n    }\n\n    fetch(urls.getValidateUrl(this, ticket), {\n      headers: {\n        'Content-Type': content_type\n      }\n    }).then(function (response) {\n      response.text().then(function (text) {\n        switch (version) {\n          case constant.CAS_VERSION_2_0:\n            xml2js.parseStringPromise(text).then(function (result) {\n              let response = result['cas:serviceResponse'];\n\n              if (response['cas:authenticationSuccess']) {\n                let successes = response['cas:authenticationSuccess'];\n\n                if (successes.length) {\n                  let user = successes[0]['cas:user'][0];\n                  let pgtIou = null;\n\n                  if (!util.isEmpty(this.proxy_callback_url)) {\n                    pgtIou = successes[0]['cas:proxyGrantingTicket'][0];\n                  }\n\n                  this._handleSuccessValdiate(resolve, user, pgtIou);\n\n                  this._handleSuccessValdiate(resolve, user);\n                }\n              } else {\n                let failures = response['cas:authenticationFailure'];\n\n                if (failures.length) {\n                  this._handleFailsValdiate(reject, {\n                    type: constant.CAS_ERROR_AUTH_ERROR,\n                    code: failures[0].$.code.trim(),\n                    message: failures[0]._.trim()\n                  });\n                }\n              }\n            }.bind(this)).catch(function (error) {\n              this._handleFailsValdiate(reject, {\n                type: constant.CAS_ERROR_PARSE_RESPONSE,\n                message: 'Failed to parse response',\n                exception: error\n              });\n            }.bind(this));\n            break;\n\n          case constant.CAS_VERSION_3_0:\n            try {\n              let json = JSON.parse(text);\n\n              if (json.serviceResponse) {\n                if (json.serviceResponse.authenticationSuccess) {\n                  let user = json.serviceResponse.authenticationSuccess.user;\n                  let pgtIou = null;\n\n                  if (!util.isEmpty(this.proxy_callback_url)) {\n                    pgtIou = json.serviceResponse.authenticationSuccess.proxyGrantingTicket;\n                  }\n\n                  this._handleSuccessValdiate(resolve, user, pgtIou);\n                } else {\n                  this._handleFailsValdiate(reject, {\n                    type: constant.CAS_ERROR_AUTH_ERROR,\n                    code: json.serviceResponse.authenticationFailure.code,\n                    message: json.serviceResponse.authenticationFailure.description\n                  });\n                }\n              }\n            } catch (error) {\n              this._handleFailsValdiate(reject, {\n                type: constant.CAS_ERROR_PARSE_RESPONSE,\n                message: 'Failed to parse response',\n                exception: error\n              });\n            }\n\n            break;\n\n          default:\n            throw util.throwError('Unsupported CAS Version');\n        }\n\n        throw util.throwError('Stop...');\n      }.bind(this)).catch(function (error) {\n        this._handleFailsValdiate(reject, {\n          type: constant.CAS_ERROR_PARSE_RESPONSE,\n          message: 'Failed to parse response',\n          exception: error\n        });\n      }.bind(this));\n    }.bind(this)).catch(function (error) {\n      this._handleFailsValdiate(reject, {\n        type: constant.CAS_ERROR_FETCH,\n        message: 'Failed to connect CAS server',\n        exception: error\n      });\n    }.bind(this));\n  }\n\n  _handleSuccessValdiate(callback, user, pgtIou = null) {\n    callback(this._getSuccessResponse(user, pgtIou));\n  }\n\n  _handleFailsValdiate(callback, error) {\n    error.currentUrl = window.location.origin + window.location.pathname;\n    error.currentPath = window.location.pathname;\n    callback(error);\n  }\n\n}\n\nexport default CasClient;\nexport { constant };"]},"metadata":{},"sourceType":"module"}